#include <gtest/gtest.h>
#include <string>
#include <fstream>
#include <functional>
#include <cstdio>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <random>
#include <thread>

#include "winfs/file_change_notifier.h"
#include "container/string_convert.h"

TEST(file_change_notifier,constructs){
    try{
    file_change_notifier fn = {L"kds:klklsd\\sdd.txt",{}};
    } catch(const file_change_notifier::win32_exception &e){
        if (e.code() >1 ){
            SUCCEED();
        } else{
            FAIL();
        }
    }

}

class file_change_fixture : public ::testing::Test
{
public:
    file_change_fixture() {
        char c_file_name[L_tmpnam]; std::tmpnam(c_file_name);
        if (c_file_name == NULL){
            throw std::runtime_error("Could not generate a temporary file name");
        }
        this->file_name_ = c_file_name;
        this->file_stream_ = std::fstream{file_name_, std::ios_base::out | std::ios_base::trunc};
        auto time_point = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
        this->file_stream_ << "This is a temporary test file generated by the file_change_fixture class at "
                           << std::put_time(std::localtime(&time_point),"%F")
                           << "\n";
        this->file_stream_.close();
    }

    std::string get_file_name() const{
        return file_name_;
    }

    void write_something(){
        this->file_stream_.open(this->file_name_,
                                std::ios_base::out | std::ios_base::out | std::ios_base::app);
        file_stream_ << "Random Input: " << this->random_() << "\n";
        file_stream_.close();
    }

private:
    std::string file_name_;
    std::fstream file_stream_;
    std::ranlux24_base random_;
};

TEST_F(file_change_fixture,detects_writing_change){
    std::atomic_bool changed = false;
    std::function<void(file_change_notifier::full_path_t)> f =
            [&changed] (file_change_notifier::full_path_t) {
            changed = true;
};
    file_change_notifier fcn(convert::to_wstring(this->get_file_name()),f);
    fcn.start_watching();
    this->write_something();

    auto sleep_point = std::chrono::steady_clock::now() + std::chrono::milliseconds(50);
    std::this_thread::sleep_until(sleep_point);
    ASSERT_TRUE(changed);
}

TEST_F(file_change_fixture,detects_multiple_changes){
    std::atomic_bool changed = false;
    std::function<void(file_change_notifier::full_path_t)> f =
            [&changed] (file_change_notifier::full_path_t) {
            changed = true;
};
    file_change_notifier fcn(convert::to_wstring(this->get_file_name()),f);
    fcn.start_watching();
    for (unsigned i = 0; i < 10; ++i){
        this->write_something();
        auto sleep_point = std::chrono::steady_clock::now() + std::chrono::milliseconds(50);
        std::this_thread::sleep_until(sleep_point);
        ASSERT_TRUE(changed);
        changed = false;
    }

}

